<!DOCTYPE html>

<html lang="English" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Ways to Add Code: Psi4NumPy, Plugins, Full Integration &#8212; Psi4 Documentation 1.11 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=61cd365c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=12dfc556" />
    <script src="../../../_static/documentation_options.js?v=29ef4520"></script>
    <script src="../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="ways-to-add-code-psi4numpy-plugins-full-integration">
<span id="sec-prog-ways-to-add"></span><h1>Ways to Add Code: Psi4NumPy, Plugins, Full Integration<a class="headerlink" href="#ways-to-add-code-psi4numpy-plugins-full-integration" title="Link to this heading">¶</a></h1>
<section id="easier-and-more-rapid-development">
<h2>Easier and more rapid development<a class="headerlink" href="#easier-and-more-rapid-development" title="Link to this heading">¶</a></h2>
<p>Fully-featured electronic structure programs are large and complex.  However,
the <a href="#id4"><span class="problematic" id="id5">|PSIfour|</span></a> ecosystem provides a path for easier and more rapid development
of new features.  The earliest versions of <a href="#id6"><span class="problematic" id="id7">|PSIfour|</span></a> were written by merging
individual executables that performed specific tasks into a unified C++
executable.  By linking this C++ executable against the Python interpreter, the
individual modules could be called in any sequence, enabling a very diverse
range of tasks to be accomplished within a given input.  Although Python-driven
model allowed for great flexibility from a user's perspective, programming was
still relatively difficult because it required modifications to be made in C++
code.</p>
<p>Since those early days, the code has undergone some important structural
changes that have greatly simplified the development workflow.  These changes
were motivated by the realization that only a few bottlenecks exist in a typical
calculation; by focusing on optimized C++ implementations of these bottlenecks
and making these C++ functions available in Python, most of the code to implement
the overall calculation can be written in simpler Python code.  Python is far
better suited to management tasks such as directory navigation and retrieval,
making it a natural choice for overall calculation layout than C++.  With the
emergence of <a class="reference external" href="https://numpy.org/">NumPy</a> as a standard tool for executing almost any
mathematical technique efficiently in Python, the transitioning of code from
C++ to Python has facilitated a much simpler work flow for prototyping and
developing methods: this is detailed in the next section.</p>
</section>
<section id="rapid-initial-development-using-psi4numpy">
<span id="sec-prog-psi4numpy"></span><h2>Rapid initial development using Psi4NumPy<a class="headerlink" href="#rapid-initial-development-using-psi4numpy" title="Link to this heading">¶</a></h2>
<p>The <a class="reference external" href="https://github.com/psi4/psi4numpy">Psi4NumPy</a> project <a class="reference internal" href="bibliography.html#smith-2018-3504" id="id1"><span>[Smith:2018:3504]</span></a> is the recommended
mechanism for developing and prototyping new methods in Psi4.  Because
<a class="reference external" href="https://numpy.org/">NumPy</a> provides such a rich set of features for efficient linear
algebra, Fourier transforms, and general tensor manipulations, a massive number
of methods can be easily implemented very easily using that library.  To
facilitate this workflow, <a href="#id8"><span class="problematic" id="id9">|PSIfour|</span></a> exports key quantities such as integrals,
densities and molecular orbitals in NumPy format.  From this point, the
programmer can simply call the appropriate <a href="#id10"><span class="problematic" id="id11">|PSIfour|</span></a> functions to compute the
desired input quantities, retrieve them in NumPy format, and then write the
remaining code using standard Python and/or NumPy syntax.  This approach does
not require any recompilation of code, resulting in a particularly facile
development workflow.  Detailed examples and tutorials are available in the
<a class="reference external" href="https://github.com/psi4/psi4numpy">Psi4NumPy</a> repository.</p>
</section>
<section id="avoiding-the-need-to-modify-psi4-using-plugins">
<span id="sec-prog-plugins"></span><h2>Avoiding the need to modify Psi4, using plugins<a class="headerlink" href="#avoiding-the-need-to-modify-psi4-using-plugins" title="Link to this heading">¶</a></h2>
<p>In the early days when <a href="#id12"><span class="problematic" id="id13">|PSIfour|</span></a> was still primarily a C++ code, development
was very cumbersome due to a lengthy build process.  To expedite development, a
plugin system was developed.  This plugin machinery allows developers to access
the classes defined in the innards of <a href="#id14"><span class="problematic" id="id15">|PSIfour|</span></a>, with only the small plugin
code requiring recompilation during development.  The resulting lightweight
code can be maintained and distributed independently of <a href="#id16"><span class="problematic" id="id17">|PSIfour|</span></a>, making this
a good strategy for development, especially in cases where tighter integration
of the new code with existing <a href="#id18"><span class="problematic" id="id19">|PSIfour|</span></a> machinery is required than that
afforded by the Numpy based strategy outlined in the <a class="reference internal" href="#sec-prog-psi4numpy"><span class="std std-ref">Rapid initial development using Psi4NumPy</span></a>
section.  For details about how to write these plugins, see the
<a class="reference internal" href="plugins.html#sec-plugins"><span class="std std-ref">Creating New Plugins</span></a> section.</p>
</section>
<section id="incorporating-code-into-psifour">
<span id="sec-prog-fullintegration"></span><h2>Incorporating code into <a href="#id20"><span class="problematic" id="id21">|PSIfour|</span></a><a class="headerlink" href="#incorporating-code-into-psifour" title="Link to this heading">¶</a></h2>
<p>For features to be incorporated fully into the <a href="#id22"><span class="problematic" id="id23">|PSIfour|</span></a> ecosystem, changes to
the core routines are inevitable.  However, the programmer should think very
carefully about the most appropriate language for the task in hand.  Let's
consider a new feature that downloads some data from an external source and
then performs some kind of expensive matrix operation on those data.  Because
Python has a rich set of tools for obtaining data from external sources,
writing this tool in the Python layer is a natural choice.  If we know that the
matrix will always be small enough to fit in memory, we can simply rely on the
routines present in NumPy to do the heavy lifting and the code is easy to
implement entirely in the Python layer.  In the case where the matrix operation
is non-standard and requires some specialized code to handle disk-based
storage, the decision to write in Python is less clear cut.  It is certainly
possible to write these out-of-core routines using Numpy primitives, but there
are a number of tools in <a href="#id24"><span class="problematic" id="id25">|PSIfour|</span></a> already to perform tasks like these that are
required, <em>e.g.</em>, for cluster.  In this case, a good design would be to write a
simple piece of code in the C++ layer that performs the matrix operation on a
given input, using the I/O routines available in <a href="#id26"><span class="problematic" id="id27">|PSIfour|</span></a> and the parallelism
afforded by OpenMP, and to make that code available to the front end as
described in <a class="reference internal" href="prog_tour.html#sec-prog-tour-exposing"><span class="std std-ref">Exposing C++ code to Python</span></a>.  The Python layer could then be
responsible for obtaining the input data and calling this C++ code to do the
manipulations, allowing each language layer to handle the subset of the work
that caters to their individual strengths.</p>
<p>A number of concrete examples of this workflow exist in the code already.  For
finite difference computations of energy derivatives, the logic to determine
the type of stencil and which displacements are needed is not going to be rate
limiting for any reasonable quantum mechanical energy function.  Therefore,
doing that work in the Python layer is a good idea, as it allows the many
Python tools for farming out <em>embarrassingly parallel</em> workloads to be used,
while the C++ layer can be used to implement the energy function to be
differentiated.</p>
<p>In SCF, we have a number of sources of external embedding potentials that could
enter the calculation.  Allowing Python to handle only the details of driving
the SCF iterations, such as external potentials and convergence acceleration
methods, but deferring to C++ to do the heavy lifting for building and
diagonalizing the Fock matrix also takes advantage of the two languages'
strengths and improves maintainability of the code.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">Psi4 Documentation</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, Harishankar.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.3.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
      |
      <a href="../../../_sources/doc/sphinxman/source/prog_ways_to_add.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>